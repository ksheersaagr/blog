<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Graph SLAM: A Noob’s Guide to Simultaneous Localisation and Mapping | Krunal Kshirsagar</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Graph SLAM: A Noob’s Guide to Simultaneous Localisation and Mapping" />
<meta name="author" content="krunal kshirsagar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Simultaneous localisation and mapping (SLAM) used in the concurrent construction of a model of the environment (the map), and the estimation of the state of the robot moving within it. In other words, SLAM gives you a way to track the location of a robot in the world in real-time and identify the locations of landmarks such as buildings, trees, rocks, and other world features. In addition to localisation, we also want to build up a model of the robot’s environment so that we have an idea of objects, and landmarks that surround it and so that we can use this map data to ensure that we are on the right path as the robot moves through the world. So the key insight in building a map is that the robot itself might lose track of where it is by virtue of its motion uncertainty since there is no presence of an existing map because we are building the map simultaneously. That’s where SLAM comes into play." />
<meta property="og:description" content="Simultaneous localisation and mapping (SLAM) used in the concurrent construction of a model of the environment (the map), and the estimation of the state of the robot moving within it. In other words, SLAM gives you a way to track the location of a robot in the world in real-time and identify the locations of landmarks such as buildings, trees, rocks, and other world features. In addition to localisation, we also want to build up a model of the robot’s environment so that we have an idea of objects, and landmarks that surround it and so that we can use this map data to ensure that we are on the right path as the robot moves through the world. So the key insight in building a map is that the robot itself might lose track of where it is by virtue of its motion uncertainty since there is no presence of an existing map because we are building the map simultaneously. That’s where SLAM comes into play." />
<link rel="canonical" href="https://ksheersaagr.github.io/blog/2020/03/graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping/" />
<meta property="og:url" content="https://ksheersaagr.github.io/blog/2020/03/graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping/" />
<meta property="og:site_name" content="Krunal Kshirsagar" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-31T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Graph SLAM: A Noob’s Guide to Simultaneous Localisation and Mapping" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"krunal kshirsagar"},"dateModified":"2020-03-31T00:00:00+00:00","datePublished":"2020-03-31T00:00:00+00:00","description":"Simultaneous localisation and mapping (SLAM) used in the concurrent construction of a model of the environment (the map), and the estimation of the state of the robot moving within it. In other words, SLAM gives you a way to track the location of a robot in the world in real-time and identify the locations of landmarks such as buildings, trees, rocks, and other world features. In addition to localisation, we also want to build up a model of the robot’s environment so that we have an idea of objects, and landmarks that surround it and so that we can use this map data to ensure that we are on the right path as the robot moves through the world. So the key insight in building a map is that the robot itself might lose track of where it is by virtue of its motion uncertainty since there is no presence of an existing map because we are building the map simultaneously. That’s where SLAM comes into play.","headline":"Graph SLAM: A Noob’s Guide to Simultaneous Localisation and Mapping","mainEntityOfPage":{"@type":"WebPage","@id":"https://ksheersaagr.github.io/blog/2020/03/graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping/"},"url":"https://ksheersaagr.github.io/blog/2020/03/graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css">
  <link rel="stylesheet" href="/blog/assets/trac.css"><link type="application/atom+xml" rel="alternate" href="https://ksheersaagr.github.io/blog/feed.xml" title="Krunal Kshirsagar" /><!---
  <link rel="shortcut icon" href="/favicon.png">
  -->
  <link rel="shortcut icon" type="image/png" href="/blog/favicon.png">

  <!-- Katex Math (use defer to speed page load) -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
        integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq"
        crossorigin="anonymous">
  <script defer
          src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
          integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
          crossorigin="anonymous"></script>
  <script defer
          src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
          integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
          crossorigin="anonymous"
          onload='renderMathInElement(document.body,{delimiters: [{left: "\\[",
          right: "\\]", display: true}, {left: "$", right: "$", display: false}]})'></script>
</head>
</head>
<body>
<div class='content'><div class='nav'>
    <ul class='wrap'>
        <!---<li><b><a href='/blog/' style="font-size:20px; color:black; padding-right: 350px"; class="split">Krunal Kshirsagar</a></b></li>-->
        <li><a href='/blog'><img src="/blog/images/home-logo-1.svg" alt="Home" style="width:20px;height:20px;"></a></li>
        <li><a href='/blog/about'><img src="/blog/images/about-logo.svg" alt="About" style="width:20px;height:20px;"></a></li>
        <li><a href="https://github.com/ksheersaagr"><img src="/blog/images/github-logo.svg" alt="Github" style="width:20px;height:20px;"></a></li>
        <li><a href="https://www.linkedin.com/in/krunal-kshirsagar/"><img src="/blog/images/linkedin-logo.svg" alt="Linkedin" style="width:20px;height:20px;"></a></li>
        <li><a href="mailto:krunalkshirsagar29@gmail.com"><img src="/blog/images/mail-logo.svg" alt="Mail" style="width:20px;height:20px;"></a></li>
    </ul>
</div>
<div class='front-matter'>
    <div class='wrap'>
        <h1>Graph SLAM: A Noob’s Guide to Simultaneous Localisation and Mapping</h1>
        <h4></h4>
        <div class='bylines'>
            <div class='byline'>
                <h3>Published by Krunal Kshirsagar</h3>
                <p>31 March 2020</p>
            </div>
        </div>
        <div class='clear'></div>
    </div>
</div>
<div class='wrap article'>
    <p>Simultaneous localisation and mapping (SLAM) used in the concurrent construction of a model of the environment (the map), and the estimation of the state of the robot moving within it. In other words, SLAM gives you a way to track the location of a robot in the world in real-time and identify the locations of landmarks such as buildings, trees, rocks, and other world features. In addition to localisation, we also want to build up a model of the robot’s environment so that we have an idea of objects, and landmarks that surround it and so that we can use this map data to ensure that we are on the right path as the robot moves through the world. So the key insight in building a map is that the robot itself might lose track of where it is by virtue of its motion uncertainty since there is no presence of an existing map because we are building the map simultaneously. That’s where SLAM comes into play.</p>

<h1 id="working-of-slam">Working of SLAM:</h1>

<p>The basis for simultaneous localisation and mapping (SLAM) is to gather information from a robot’s sensors and motions over time, and then use information about measurements and motion to reconstruct a map of the world. In this case, we’ll be localizing a robot in a 2D grid world and therefore, a <strong><a href="http://www2.informatik.uni-freiburg.de/~stachnis/pdf/grisetti10titsmag.pdf">graph-based SLAM approach constructs a simplified estimation problem by abstracting the raw sensor measurements. These raw measurements are replaced by the edges in the graph which can then be seen as virtual measurements</a>.</strong><br />
Let’s assume we have a robot and the initial location, <strong>x0=0 &amp; y0=0.</strong> For this example, we don’t care about heading direction just to keep things simple. Let’s assume the robot moves to the right in the X-direction by <strong>10</strong>. So, In a perfect world, you would know that <strong>x1</strong>, the location after motion is the same as <strong>x0+10</strong> in other words, <strong>x1=x0+10</strong>, and <strong>y1</strong> is the same as <strong>y0.</strong></p>

<p><img src="/blog/images/2020-03-31-graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping-displacement-by-10.png " /></p>

<p>But according to <strong><a href="https://ksheersaagr.github.io/blog/2020/02/the-curious-case-of-kalman-filters/">Kalman filters</a></strong> and various other robotic techniques, we have learned that the <strong>location is actually uncertain</strong>. So, rather than assuming in our X-Y coordinate system the robot moved to the right by 10 exactly, it’s better to understand that the actual location of the robot after the x1= x0+10 motion update is a Gaussian centered around (10,0), but it’s possible that the robot is somewhere else.</p>

<p><img src="/blog/images/2020-03-31-graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping-gaussian-centered-around-the-location-of-robot-after-motion-update.png " /></p>

<h1 id="heres-the-math-for-the-gaussian-of-x-variable">Here’s the math for the Gaussian of x variable:</h1>

<p>Rather than setting x1 to x0+10, let’s express it in Gaussian that peaks when these two things are the same. So, if you subtract x1-x0-10, put this into a square format, and turn this into a Gaussian, we get a probability distribution that relates x1 and x0. We can do the same for y. Since there is no change in y according to our motion, y1 &amp; y0 are as close together as possible.</p>

<p><img src="/blog/images/2020-03-31-graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping-likelihood.png " /></p>

<p>The product of these two Gaussian is now our constraint. The goal is to maximize the likelihood of the position x1 given the position x0 is (0,0). <strong>So, what graph-SLAM does is, it defines the probabilities using a sequence of such constraints.</strong> Say we have a robot that moves in some space, GRAPH SLAM collects its initial location which is (0,0) initially, also called as <strong>Initial Constraints</strong>, then collects lots of relative constraints that relate each robot pose to the previous robot pose also called as <strong>Relative Motion Constraints.</strong> As an example, let’s use landmarks that can be seen by the robot at various locations which would be <strong>Relative Measurement Constraints</strong> every time a robot sees a landmark. <strong>So, Graph SLAM collects those constraints in order to find the most likely configuration of the robot path along with the location of landmarks, and that is the mapping process.</strong></p>

<p><img src="/blog/images/2020-03-31-graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping-update-position.png " /></p>

<h2 id="implementation">Implementation</h2>

<h1 id="generating-an-environment">Generating an environment:</h1>
<p>We will generate a 2D world grid with landmarks in it and then generate data by placing a robot in that world and moving and sensing over some number of time steps. The data is collected as an instantiated robot moves and senses in a world. Our SLAM function will take in this data as input. So, let’s first create this data and explore how it represents the movement and sensor measurements that our robot takes.</p>

<h1 id="slam-inputs">SLAM inputs:</h1>

<h4 id="in-addition-to-data-our-slam-function-takes-in">In addition to data, our slam function takes in:</h4>

<ul>
  <li><strong>N:</strong> The number of time steps that a robot will be moving and sensing.</li>
  <li><strong>num_landmarks:</strong> The number of landmarks in the world.</li>
  <li><strong>world_size:</strong> The size (w/h) of your world.</li>
  <li><strong>motion_noise:</strong> The noise associated with motion; the update confidence for motion should be <code class="highlighter-rouge">1.0/motion_noise</code>.</li>
  <li><strong>measurement_noise:</strong> The noise associated with measurement/sensing; the update weight for measurement should be <code class="highlighter-rouge">1.0/measurement_noise</code>.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">helpers</span> <span class="kn">import</span> <span class="n">make_data</span>

<span class="c1"># your implementation of slam should work with the following inputs
# feel free to change these input values and see how it responds!
</span>
<span class="c1"># world parameters
</span><span class="n">num_landmarks</span>      <span class="o">=</span> <span class="mi">5</span>        <span class="c1"># number of landmarks
</span><span class="n">N</span>                  <span class="o">=</span> <span class="mi">20</span>       <span class="c1"># time steps
</span><span class="n">world_size</span>         <span class="o">=</span> <span class="mf">100.0</span>    <span class="c1"># size of world (square)
</span>
<span class="c1"># robot parameters
</span><span class="n">measurement_range</span>  <span class="o">=</span> <span class="mf">50.0</span>     <span class="c1"># range at which we can sense landmarks
</span><span class="n">motion_noise</span>       <span class="o">=</span> <span class="mf">2.0</span>      <span class="c1"># noise in robot motion
</span><span class="n">measurement_noise</span>  <span class="o">=</span> <span class="mf">2.0</span>      <span class="c1"># noise in the measurements
</span><span class="n">distance</span>           <span class="o">=</span> <span class="mf">20.0</span>     <span class="c1"># distance by which robot (intends to) move each iteratation 
</span>

<span class="c1"># make_data instantiates a robot, AND generates random landmarks for a given world size and number of landmarks
</span><span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">num_landmarks</span><span class="p">,</span> <span class="n">world_size</span><span class="p">,</span> <span class="n">measurement_range</span><span class="p">,</span> <span class="n">motion_noise</span><span class="p">,</span> <span class="n">measurement_noise</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="lets-write-our-two-main-functions-that-move-our-robot-around-help-locate-landmarks-and-measure-the-range-between-them-on-a-2d-map">Let’s write our two main functions that move our robot around, help locate landmarks and measure the range between them on a 2D map:</h1>

<ul>
  <li><strong>Move:</strong> attempts to move the robot by dx, dy.
Sense: returns x and y distances to landmarks within the visibility range.</li>
  <li><strong>Sense:</strong> returns x and y distances to landmarks within the visibility range.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">robot</span><span class="p">:</span>
    
    <span class="c1">#move function
</span>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">motion_noise</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">motion_noise</span>
        
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">world_size</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">world_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">return</span> <span class="bp">True</span>
    
    
    <span class="c1">#sense function
</span>    <span class="k">def</span> <span class="nf">sense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">landmark_index</span><span class="p">,</span> <span class="n">landmark</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">landmarks</span><span class="p">):</span>
            <span class="n">landmark_distance_x</span> <span class="o">=</span> <span class="n">landmark</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">landmark_distance_y</span> <span class="o">=</span> <span class="n">landmark</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">random_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span>
            <span class="n">cal_dx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">landmark_distance_x</span> <span class="o">+</span> <span class="n">random_noise</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">measurement_noise</span>
            <span class="n">cal_dy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">landmark_distance_y</span> <span class="o">+</span> <span class="n">random_noise</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">measurement_noise</span>
            <span class="n">is_not_in_measurement_range</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">measurement_range</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span><span class="p">(</span><span class="n">is_not_in_measurement_range</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">cal_dx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">measurement_range</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cal_dy</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">measurement_range</span><span class="p">)):</span>
                <span class="n">measurements</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">landmark_index</span><span class="p">,</span> <span class="n">cal_dx</span><span class="p">,</span> <span class="n">cal_dy</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">measurements</span>
</code></pre></div></div>

<h1 id="omega-and-xi">Omega and Xi:</h1>
<p>To implement Graph SLAM, a matrix and a vector (omega and xi, respectively) are introduced. The matrix is square, labeled with all the robot poses (xi) and all the landmarks. Every time you make an observation, for example, as you move between two poses by some distance dx and can relate those two positions, you can represent this as a numerical relationship in these matrices. let’s write the function such that it returns omega and xi constraints for the starting position of the robot. Any values that we do not yet know should be initialized with the value 0. we may assume that our robot starts out in exactly the middle of the world with 100% confidence.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize_constraints</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">num_landmarks</span><span class="p">,</span> <span class="n">world_size</span><span class="p">):</span>
    <span class="s">''' This function takes in a number of time steps N, number of landmarks, and a world_size,
        and returns initialized constraint matrices, omega and xi.'''</span>
    
    <span class="n">middle_of_the_world</span> <span class="o">=</span> <span class="n">world_size</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="c1">## Recommended: Define and store the size (rows/cols) of the constraint matrix in a variable
</span>    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">num_landmarks</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">num_landmarks</span><span class="p">)</span>
    <span class="c1">## TODO: Define the constraint matrix, Omega, with two initial "strength" values
</span>    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="c1">## for the initial x, y location of our robot
</span>    <span class="c1">#omega = [0]
</span>    
    <span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span>
    
    <span class="c1">## TODO: Define the constraint *vector*, xi
</span>    <span class="c1">## you can assume that the robot starts out in the middle of the world with 100% confidence
</span>    <span class="c1">#xi = [0]
</span>    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_of_the_world</span>
    <span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_of_the_world</span>
    
    <span class="k">return</span> <span class="n">omega</span><span class="p">,</span> <span class="n">xi</span>
</code></pre></div></div>

<h1 id="updating-with-motion-and-measurements">Updating with motion and measurements:</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## slam takes in 6 arguments and returns mu, 
## mu is the entire path traversed by a robot (all x,y poses) *and* all landmarks locations
</span><span class="k">def</span> <span class="nf">slam</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">num_landmarks</span><span class="p">,</span> <span class="n">world_size</span><span class="p">,</span> <span class="n">motion_noise</span><span class="p">,</span> <span class="n">measurement_noise</span><span class="p">):</span>
    
    <span class="c1">## TODO: Use your initilization to create constraint matrices, omega and xi
</span>    <span class="n">omega</span><span class="p">,</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">initialize_constraints</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">num_landmarks</span><span class="p">,</span> <span class="n">world_size</span><span class="p">)</span>
    <span class="c1">## TODO: Iterate through each time step in the data
</span>    <span class="k">for</span> <span class="n">time_step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        
        <span class="c1">## get all the motion and measurement data as you iterate through each time step
</span>        <span class="n">measurement</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">time_step</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">motion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">time_step</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">dx</span> <span class="o">=</span> <span class="n">motion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>         <span class="c1"># distance to be moved along x in this time_step
</span>        <span class="n">dy</span> <span class="o">=</span> <span class="n">motion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>         <span class="c1"># distance to be moved along y in this time_step
</span>        
        <span class="c1">#Consider the robot moves from (x0,y0) to (x1,y1) in this time_step
</span>        
        <span class="c1">#even numbered columns of omega correspond to x values
</span>        <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_step</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1">#x0 = 0,2,4,...
</span>        <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="mi">2</span>            <span class="c1">#x1 = 2,4,6,...
</span>        
        <span class="c1">#odd numbered columns of omega correspond to y values
</span>        <span class="n">y0</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="mi">1</span>            <span class="c1">#y0 = 1,3,5,...
</span>        <span class="n">y1</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="mi">2</span>            <span class="c1">#y1 = 3,5,7,...
</span>        
        <span class="n">actual_m_noise</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">measurement_noise</span>
        <span class="n">actual_n_noise</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">motion_noise</span>
    <span class="c1">## TODO: update the constraint matrix/vector(omega/xi) to account for all *measurements*
</span>    <span class="c1">## this should be a series of additions that take into account the measurement noise
</span>        <span class="k">for</span> <span class="n">landmark</span> <span class="ow">in</span> <span class="n">measurement</span><span class="p">:</span>
            <span class="n">lM</span> <span class="o">=</span> <span class="n">landmark</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>            <span class="c1"># landmark id
</span>            <span class="n">dx_lM</span> <span class="o">=</span> <span class="n">landmark</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>         <span class="c1"># separation along x from current position
</span>            <span class="n">dy_lM</span> <span class="o">=</span> <span class="n">landmark</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>         <span class="c1"># separation along y from current position
</span>            
            <span class="n">L_x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">lM</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># even-numbered columns have x values of landmarks
</span>            <span class="n">L_y0</span> <span class="o">=</span> <span class="n">L_x0</span> <span class="o">+</span> <span class="mi">1</span>             <span class="c1"># odd-numbered columns have y values of landmarks
</span>
            <span class="c1"># update omega values corresponding to measurement between x0 and Lx0
</span>            <span class="n">omega</span><span class="p">[</span><span class="n">x0</span><span class="p">][</span><span class="n">x0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_m_noise</span>
            <span class="n">omega</span><span class="p">[</span><span class="n">L_x0</span><span class="p">][</span><span class="n">L_x0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_m_noise</span>
            <span class="n">omega</span><span class="p">[</span><span class="n">x0</span><span class="p">][</span><span class="n">L_x0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_m_noise</span>
            <span class="n">omega</span><span class="p">[</span><span class="n">L_x0</span><span class="p">][</span><span class="n">x0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_m_noise</span>
            
            <span class="c1"># update omega values corresponding to measurement between y0 and Ly0
</span>            <span class="n">omega</span><span class="p">[</span><span class="n">y0</span><span class="p">][</span><span class="n">y0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_m_noise</span>
            <span class="n">omega</span><span class="p">[</span><span class="n">L_y0</span><span class="p">][</span><span class="n">L_y0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_m_noise</span>
            <span class="n">omega</span><span class="p">[</span><span class="n">y0</span><span class="p">][</span><span class="n">L_y0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_m_noise</span>
            <span class="n">omega</span><span class="p">[</span><span class="n">L_y0</span><span class="p">][</span><span class="n">y0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_m_noise</span>
            
            <span class="c1"># update xi values corresponding to measurement between x0 and Lx0
</span>            <span class="n">xi</span><span class="p">[</span><span class="n">x0</span><span class="p">]</span>  <span class="o">-=</span> <span class="n">dx_lM</span><span class="o">/</span><span class="n">measurement_noise</span>
            <span class="n">xi</span><span class="p">[</span><span class="n">L_x0</span><span class="p">]</span>  <span class="o">+=</span> <span class="n">dx_lM</span><span class="o">/</span><span class="n">measurement_noise</span>
            
            <span class="c1"># update xi values corresponding to measurement between y0 and Ly0
</span>            <span class="n">xi</span><span class="p">[</span><span class="n">y0</span><span class="p">]</span>  <span class="o">-=</span> <span class="n">dy_lM</span><span class="o">/</span><span class="n">measurement_noise</span>
            <span class="n">xi</span><span class="p">[</span><span class="n">L_y0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dy_lM</span><span class="o">/</span><span class="n">measurement_noise</span>
            
            
        <span class="c1">## TODO: update the constraint matrix/vector(omega/xi) to account for all *motion* from from (x0,y0) to (x1,y1) and motion noise
</span>        <span class="n">omega</span><span class="p">[</span><span class="n">x0</span><span class="p">][</span><span class="n">x0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_n_noise</span>
        <span class="n">omega</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_n_noise</span>
        <span class="n">omega</span><span class="p">[</span><span class="n">x0</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_n_noise</span>
        <span class="n">omega</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">x0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_n_noise</span>
        
        <span class="n">omega</span><span class="p">[</span><span class="n">y0</span><span class="p">][</span><span class="n">y0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_n_noise</span>
        <span class="n">omega</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">actual_n_noise</span>
        <span class="n">omega</span><span class="p">[</span><span class="n">y0</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_n_noise</span>
        <span class="n">omega</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">y0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">actual_n_noise</span>
        
        <span class="n">xi</span><span class="p">[</span><span class="n">x0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dx</span><span class="o">/</span><span class="n">motion_noise</span>
        <span class="n">xi</span><span class="p">[</span><span class="n">y0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dy</span><span class="o">/</span><span class="n">motion_noise</span>
        
        <span class="n">xi</span><span class="p">[</span><span class="n">x1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dx</span><span class="o">/</span><span class="n">motion_noise</span>
        <span class="n">xi</span><span class="p">[</span><span class="n">y1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dy</span><span class="o">/</span><span class="n">motion_noise</span>
    
    <span class="c1">## TODO: After iterating through all the data
</span>    <span class="c1">## Compute the best estimate of poses and landmark positions
</span>    <span class="c1">## using the formula, omega_inverse * Xi
</span>    <span class="n">inverse_of_omega</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">omega</span><span class="p">))</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">inverse_of_omega</span> <span class="o">*</span> <span class="n">xi</span>
    
    <span class="k">return</span> <span class="n">mu</span>
</code></pre></div></div>

<h1 id="robot-poses--landmarks">Robot Poses &amp; Landmarks:</h1>

<p>Let’s print the estimated pose and landmark locations that our function has produced. We define a function that extracts the poses and landmarks locations and returns those as their own separate lists.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_poses_landmarks</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="c1"># create a list of poses
</span>    <span class="n">poses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">poses</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">mu</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">].</span><span class="n">item</span><span class="p">(),</span> <span class="n">mu</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">item</span><span class="p">()))</span>

    <span class="c1"># create a list of landmarks
</span>    <span class="n">landmarks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_landmarks</span><span class="p">):</span>
        <span class="n">landmarks</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">mu</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">i</span><span class="p">)].</span><span class="n">item</span><span class="p">(),</span> <span class="n">mu</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">item</span><span class="p">()))</span>

    <span class="c1"># return completed lists
</span>    <span class="k">return</span> <span class="n">poses</span><span class="p">,</span> <span class="n">landmarks</span>
  
<span class="k">def</span> <span class="nf">print_all</span><span class="p">(</span><span class="n">poses</span><span class="p">,</span> <span class="n">landmarks</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Estimated Poses:'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poses</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'['</span><span class="o">+</span><span class="s">', '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'%.3f'</span><span class="o">%</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poses</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s">']'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Estimated Landmarks:'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">landmarks</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'['</span><span class="o">+</span><span class="s">', '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'%.3f'</span><span class="o">%</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">landmarks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s">']'</span><span class="p">)</span>

<span class="c1"># call your implementation of slam, passing in the necessary parameters
</span><span class="n">mu</span> <span class="o">=</span> <span class="n">slam</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">num_landmarks</span><span class="p">,</span> <span class="n">world_size</span><span class="p">,</span> <span class="n">motion_noise</span><span class="p">,</span> <span class="n">measurement_noise</span><span class="p">)</span>

<span class="c1"># print out the resulting landmarks and poses
</span><span class="k">if</span><span class="p">(</span><span class="n">mu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
    <span class="c1"># get the lists of poses and landmarks
</span>    <span class="c1"># and print them out
</span>    <span class="n">poses</span><span class="p">,</span> <span class="n">landmarks</span> <span class="o">=</span> <span class="n">get_poses_landmarks</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">print_all</span><span class="p">(</span><span class="n">poses</span><span class="p">,</span> <span class="n">landmarks</span><span class="p">)</span>
</code></pre></div></div>
<h4 id="estimated-robot-poses-and-landmarks">Estimated Robot poses and landmarks</h4>

<p><img src="/blog/images/2020-03-31-graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping-estimated-robot-poses-and-landmarks.png " /></p>

<h1 id="visualise-the-constructed-world">Visualise the constructed world:</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># import the helper function
</span><span class="kn">from</span> <span class="nn">helpers</span> <span class="kn">import</span> <span class="n">display_world</span>

<span class="c1"># Display the final world!
</span>
<span class="c1"># define figure size
</span><span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s">"figure.figsize"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># check if poses has been created
</span><span class="k">if</span> <span class="s">'poses'</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
    <span class="c1"># print out the last pose
</span>    <span class="k">print</span><span class="p">(</span><span class="s">'Last pose: '</span><span class="p">,</span> <span class="n">poses</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># display the last position of the robot *and* the landmark positions
</span>    <span class="n">display_world</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">world_size</span><span class="p">),</span> <span class="n">poses</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">landmarks</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="output">Output:</h4>

<p><img src="/blog/images/2020-03-31-graph-slam-a-noobs-guide-to-simultaneous-localisation-and-mapping-lastpose.png " /></p>

<p>Check out the code on <strong><a href="https://github.com/ksheersaagr/Landmark_Detection_Robot_Tracking_SLAM-">Github.</a></strong></p>

</div>
<div id='bibliography'>
    <div class='wrap'>
        <ol class="bibliography"></ol>
    </div>
</div>

</div>
</body>
</html>
